/*
Q29: Consider all integer combinations of a^b for 2 < a < 5 and 2 < b < 5:

2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125.
How many distinct terms are in the sequence generated by a^b for 2 < a < 100 and 2 < b < 100?
*/

/*
We cannot brute force this since 100^100 is 1e200. Thats too big.
All prime bases will result in distinct results. The repeats only come when we deal with numbers which are powers of a number. For example, a=2 and a=3 will lead to distinct results. But a=4 will cause repeation since 4^b = 2^2b. In fact, the repetiion occurs for b < n/2.
a=6 will not cause repetition. Thats because its prime factorisation is 2 * 3. 


Lets say we are at i = 2.
Now this will obviously have 99 distinct results (2^2 to 2^100).
The concern lies in 2 different types of results.
1. Results that are smaller or equal to 100. They can be used as bases and hence be repeated.
2. Results that have composite powers. They can be derived by powering results smaller than them (eg 16 = 4^2).

For 4 = 2^2, the repeats will last until 4^50 = 2^100. After which, from b=51 to b=100, the result will be a unique one. 
For 8 = 2^3, repeats will last until 8^33 = 2^99. After which, from b=34 to b=100, the result will be a unique one. 
For 16 = 2^4, repeats would last until 16^25 = 2^100. However, 16 = 4^2 too. So the repeats will actually last until 16^50 = 4^100. After which, from b=51 to b=100, the result will be a unique one. 
For 64 = 2^6, repeats would last until 16^16 = 2^96. However, 64 = 8^2 too. So the repeats will actually last until 64^50 = 8^100. After which, from b=51 to b=100, the result will be a unique one.
For 512 = 2^9, repeats would last until 512^11 = 2^99. However, 512 = 8^3. So repeats will actually last until 512^33 = 8^99. After which, from b=34 to b=100, the result will be a unique one. 

The pattern here is that for k = i^j, where j is prime, repeats will last until k^(100 / j). After which, from b=100/j + 1 to b = 100, the result will be unique. If j is composite, then split j into its prime factors and condense it into a form q^p such that p is prime and q is as big as possible (like how for 64 we didnt split it to 4^3, instead we split it into 8^2).

The algorithrm is as such:
1. Create bool array of seen numbers (preferably length 101 for easy indexing). Init to false.
2. Intiailise a counter and start a for loop from 2 to 100. 
3. Add 99 to the counter.
4. Initiliase an array of seen powers. This array will store the largest number that has seen the element.
5. Loop through the array. For each index, store the index into elements with a index being the multiple of the curr index. For example if we start at index 2 (since we start frm power 2), then index 4, 8, 16 and so on will store the number 2. NOTE: update the index only if a^index <= 100 (since if its greater than 100, then it cannot be used as a base).
6. If the current element is not 0, then that means that some result smaller has already included the element. So we set j = index / element.
7. If the current element is 0, then it is an unseen number. So we set j = index only if the result is smaller or equal to 100. (since if its greater than 100, then it cannot be used as a base).
8. Add 100 - 100/j to the counter.
6. Once the loops end, print counter.
*/
/*
New method:
Notice the problem always lie in the numbers that are powers of others. In fact, we only need to care about the biggest number and its base. For example, in our case, for the base 2, the largest power that can be used as a base is 64 (2^6). Notice that if we increase our range for the powers of 2 from 2^2 - 2^100 to 2^2 - 2^600, then we will have covered every single power of 2 that can be derived in our range of values.

The problem now lies in that we will produce results that cannot even appear. In the example given, 128 is not a result, but our method produces it. We need to remove these extra results.
Notice that the increasing of range is to accomodate for the solutions produced by other powers as bases. This means that the bigger results must have a power that is a multiple of a smaller power. Essentially, 256 is a valid result because it is 2^8, and 8 is a multiple of 2 and 2^2 = 4. Since 4 is in the range of 2-5, 256 is a possible result. 128 and 512 are not possible because the power of 128 is a prime 7, and power of 512 is 9=3*3, and 2^3=8 is out of the range.

So the idea now is simple:
1. Create bool array of seen numbers (preferably length 101 for easy indexing). Init to false.
2. Intiailise a counter and start a for loop from 2 to 100. 
3. Find the largest result below 100 and set j=power.
4. Initialise a new bool array with 100 * j + 1 terms. This is to track which multiples we have visited
4. Loop through the powers below 100.
5. Firstly, update the main bool array.
6. Get all the multiples of the power starting from N+1 up till 100 * power. 100*power will be the largest power possible when the original result is the base.
7. Check that the multiples have not been visited and update the multiples array. Add the number of valid multiples to the counter.
8. Add 99 to the counter after the loop is done, to account for the original 99 numbers.
*/

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

int main() {
    int N = 100;
    int p, n, c = 0, m;
    bool seen[N + 1];
    bool *seenpowers = malloc(1);

    memset(seen, false, sizeof(seen));

    for (int a = 2; a <= N; a++) {
        if (seen[a]) continue;
        n = a; m = 0;
        for (int i = 2; i <= N; i++) {
            n *= a;
            if (n > N) {
                p = i - 1; break;
            }
            seen[n] = true;
        }
        seenpowers = realloc(seenpowers, (N*p+1) * sizeof(bool));
        for (int i = 0; i <= N*p+1; i++) seenpowers[i] = (bool)(i <= 10);

        for (int i = 2; i <= p; i++) {
            if (i > N && seenpowers[i] == true) continue;
            for (int j = i * 2; j <= N * i; j += i) {
                if (seenpowers[j] == false && j > N) {
                    m++;
                }
                seenpowers[j] = true;
            }
        }
        c += m + N - 1;
    }

    printf("%d\n", c);
    return 0;
}