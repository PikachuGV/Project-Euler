/*
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
Triangle 
P{3,n}=n(n+1)/2
1, 3, 6, 10, 15, ...

Square
P{4,n}=n^2
1, 4, 9, 16, 25, ...

Pentagonal
P{5,n}=n(3n-1)/2
1, 5, 12, 22, 35, ...

Hexagonal 
P{6,n}=n(2n-1)
1, 6, 15, 28, 45, ...

Heptagonal
P{7,n}=n(5n-3)/2
1, 7, 18, 34, 55, ...

Octagonal 
P{8,n}=n(3n-2)
1, 8, 21, 40, 65, ...


The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
Each polygonal type: triangle (P{3,127}=8128), square (P{4,91}=8281), and pentagonal (P{5,44}=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
*/

/*
Test for each polygonal number:
    Triangle: 8n+1 is perfect square
    Square: n is perfect square
    Pentagonal: 24n+1 is perfect square AND sqrt(24n+1) = 5 mod 6
    Hexagonal: 8n+1 is perfect square AND sqrt(8n+1) = 3 mod 4 
    Heptagonal: 40n+9 is perfect square AND sqrt(40n+9) = 7 mod 10
    Octagonal: 3n+1 is perfect square AND sqrt(3n+1) = 2 mod 3

    In our range, all hexagonal numbers are also triangular numbers but not vice versa. 
    
The smallest and largest polygonal number for each type in range (4 digits):
    Triangle: 1035 (45th) and 9870 (140th)
    Square: 1024 (32nd) and 9801 (99th)
    Pentagonal: 1001 (26th) and 9801 (81th)
    Hexagonal: 1035 (23rd) and 9730 (70th)
    Heptagonal: 1071 (21st) and 9828 (63rd)
    Octagonal: 1045 (19th) and 9976 (58th)
    
    We need save square numbers from 1000 to 40009. -> 32^2 to 200^2
    */
   
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <sys/time.h>

double get_time()
{
    struct timeval t;
    struct timezone tzp;
    gettimeofday(&t, &tzp);
    return t.tv_sec + t.tv_usec*1e-6;
}
   
const int S = 1000, E = 400009;

enum POLYGONS {
    NONE,
    TRIANGLE,
    SQUARE,
    PENTAGON,
    HEXAGON,
    HEPTAGON,
    OCTAGON
};

int floorsqrt(int n) {
    int g = n / 2, new = ((g + n/g) >> 1);
    while (new != g) {
        g = new;
        new  = ((g + n/g) >> 1);
    }
    return g;
}

bool* genSquares(int start, int end) {
    bool *squares = calloc(end-start+1, sizeof(bool));

    int s = floorsqrt(start); if (s * s < start) s++;

    for (int i = s; i * i <= end; i++) {
        squares[i * i - start] = true;
    }

    return squares;
}

int* genPolygons(int ***polygons, int **lens, bool **squares, int start, int end) {
    int *t=lens[0], *s=lens[1], *p=lens[2], *hx=lens[3], *hp=lens[4], *o=lens[5];
    for (int n = start; n <= end; n++) {
        if ((*squares)[(8*n+1) - S]) {
            (*polygons[0])[*t] = n; (*t)++;
            if ((floorsqrt(8*n+1) & 0b11) == 3) {
                (*polygons[3])[*hx] = n; (*hx)++;
            }
        }

        if ((*squares)[n - S]) {
            (*polygons[1])[*s] = n; (*s)++;
        }

        if ((*squares)[(24*n+1) - S] && (floorsqrt(24*n+1) % 6) == 5) {
            (*polygons[2])[*p] = n; (*p)++;
        }

        if ((*squares)[(40*n+9) - S] && (floorsqrt(40*n+9) % 10) == 7) {
            (*polygons[4])[*hp] = n; (*hp)++;
        }

        if ((*squares)[(3*n+1) - S] && (floorsqrt(3*n+1) % 3) == 2) {
            (*polygons[5])[*o] = n; (*o)++;
        }
    }

}

int binarySearchLimited(int *arr, int len, int n, int times) {
    //Unsure whether this works well, seems to not work well for small times.
    int mid, offset = 0;
    if (arr[len - 1] <= n) return len - 1;
    if (arr[0] >= n) return 0;

    for (int i = 0; i < times; i++) {
        mid = len >> 1;
        if (arr[mid + offset] == n) return mid + offset;
        if (arr[mid + offset] < n && arr[mid + offset + 1] > n) return mid + offset;
        if (arr[mid + offset] > n && arr[mid - 1 + offset] < n) return mid - 1 + offset;

        if (arr[mid + offset] > n) {
            len = mid; 
        } else {
            offset += (mid + 1); len -= (mid + 1); 
        }
    }
    return (len >> 1) + offset;
}

bool search(int depth, int **seen, int **polygons[6], int *lens[6], int N) {
    //First 2 digits with last two 0s
    int n = (N % 100) * 100;

    //Should the depth be 6, it means that we have found a full set of numbers
    if (depth == 6) {
        //Check if the recently added number and the octagonal number are cyclic pair
        return (n == ((*seen)[5] / 100) * 100);
    }

    int index, *polygon, len;
    for (int i = 0; i < 5; i++) {
        //If seen[i] is 0 that means that we havaent found that corresponding polygon number
        if ((*seen)[i] == 0) {
            polygon = *polygons[i]; len = *lens[i];
            for (int j = binarySearchLimited(polygon, len, n, 3); j < len; j++) {
                //Search through the polygon array, using binary search to find start might help a little

                //If our binary search is too far off then we just skip the first few numbers
                if (polygon[j] < n) continue;
                
                //When the number doesnt have the same first 2 digits then we break out
                if (polygon[j] > n + 99) break;

                (*seen)[i] = polygon[j];
                if (search(depth + 1, seen, polygons, lens, polygon[j])) {
                    return true;
                }

                //Reset the seen number to 0
                (*seen)[i] = 0;
            }
        }
    }
    //Reaching here means that we found no possible set. So return false
    return false;
}


int main() {
    double start = get_time();
    bool *squares = genSquares(S, E);
    
    int *triangle, *square, *pentagonal, *hexagonal, *heptagonal, *octagonal;
    int t = 0, s = 0, p = 0, hx = 0, hp = 0, o = 0;
    
    //Initialise array to have 9001 elements since there are 9001 4 digit numbers.
    triangle = malloc(9001 * sizeof(int));
    square = malloc(9001 * sizeof(int));
    pentagonal = malloc(9001 * sizeof(int));
    hexagonal = malloc(9001 * sizeof(int));
    heptagonal = malloc(9001 * sizeof(int));
    octagonal = malloc(9001 * sizeof(int));
    
    int **polygons[6] = {&triangle, &square, &pentagonal, &hexagonal, &heptagonal, &octagonal}; 
    int *lens[6] = {&t, &s, &p, &hx, &hp, &o};

    genPolygons(polygons, lens, &squares, 1000, 10000);
    int *seen = calloc(6, sizeof(int)), sum = 0;
    for (int i = 0; i < *lens[5]; i++) {
        seen[5] = (*polygons[5])[i];
        if (search(1, &seen, polygons, lens, (*polygons[5])[i])) {
            for (int i = 0; i < 6; i++) {
                sum += seen[i];
            }
            break;
        }
        memset(seen, 0, 6 * sizeof(int));
    }    
    double time = get_time() - start;
    printf("%d\nTime Taken: %lf", sum, time);
    return 0;
}